const secrets = require('secrets.js-grempe'),
  Wallet = require('ethereumjs-wallet'),
  EthUtil = require('ethereumjs-util'),
  _ = require('lodash'),
  Web3 = require('web3'),
  web3 = new Web3();

//all nodes should accept some code and process the signed message output.
//the collaboration of all signed data should be the proof of accepted work

let pw = 'hello consensus'; //generated by node, which wants to commit the record

let privKeys = _.chain(new Array(5)).fill(1).map(() => Wallet.generate().getPrivateKey().toString('hex')).value();

let pwHex = secrets.str2hex(pw); // => hex string

let shares = secrets.share(pwHex, privKeys.length, 3);

console.log(shares);

let signedShares = shares.map((share, i) => //each node sign it's share secret
  web3.eth.accounts.sign(share, `0x${privKeys[i]}`)
);


let validatedShares = _.reduce(signedShares, (result, signedShare, i)=>{

  const publicKey = EthUtil.ecrecover(Buffer.from(signedShare.messageHash.replace('0x', ''), 'hex'), parseInt(signedShare.v), Buffer.from(signedShare.r.replace('0x', ''), 'hex'), Buffer.from(signedShare.s.replace('0x', ''), 'hex'));

  let peerPubKey = Wallet.fromPrivateKey(Buffer.from(privKeys[i], 'hex')).getPublicKey().toString('hex');

  if(peerPubKey === publicKey.toString('hex'))
    result.push(signedShare.message);

  return result;

}, []);


// combine 2 shares:
let comb = secrets.combine(validatedShares);

//convert back to UTF string:
comb = secrets.hex2str(comb);

console.log(comb)

console.log(comb === pw); // => false